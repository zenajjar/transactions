# Transaction Validator
This library parses and validates transactions with a predefined model currently supporting JSON and XML and provides an extendable interface to support more formats.

# Usage
The validator uses dependency injection as it requires a parser to support your data format.

```python
from transactions import *

# initialize the validator injecting the parser
json_validator = TransactionValidator(parser=parse_json_transaction)
# retrieve your data. could be a DB query or a user request.
transaction_str = open('res/transaction.json').read()
# pass the formatted string to the validator 
transaction = json_validator(transaction_str)
```

The parser is a callable that takes a string and returns a `Transaction` so new parsers can be implemented and passed to the validator to support new formats.  

The validator will run the transactions through consistency tests and in case a transaction fails to pass the tests, the validator raises an error with a detailed message.

The validator can also take preparsed transactions in case they get parsed or initialized in a different part of the application.

### Dependencies:
This library requires `Pydantic` and `xmltodict` which could be installed with the following commands:
```shell
pip install pydantic
pip install xmltodict
```
please note that this library requires python 3.6+.

# Design
Designing this library I was aiming for three things:
- Writing clean and easy to maintain code. 
- Making it as decoupled as possible from the model so that both it and the model can evolve independently of each other.
- Providing an extendable interface by allowing new parsers to be easily added.

I'm going to go over the modules in my library and explain each of their roles and rationalize some of the decisions I made.

## Model
Building the model, I decided to go with the `pydantic` library for the following reasons:
- It provides a really easy and elegant way to define the model with minimal boilerplate. For example this is how the `Tax` class would look like using the plain python syntax:
```python
class Tax:
    def __init__(self, id_: UUID,
                 name: str,
                 rate: float,
                 inclusion_type: str,
                 is_custom_amount: bool,
                 applied_money: MoneyAmount):
        self.id = id_
        self.name = name
        self.rate = rate
        self.inclusion_type = inclusion_type
        self.is_custom_amount = is_custom_amount
        self.applied_money = applied_money
```
On the other hand, it's a simple as this using the `pydantic` library:

```python
class Tax(FrozenModel):
    id: UUID
    name: str
    rate: float
    inclusion_type: str
    is_custom_amount: bool
    applied_money: MoneyAmount
```

- It provides really useful tools for encoding and decoding the defined model. For example, it provides a tool to parse models from a dictionary which could be useful parsing formats like JSON which is structured as nested dictionaries.  
It also automatically parses the UUID and datetime objects.

## Parse
This module has two parsers for JSON and XML. As mentioned before, the parser is defined as a callable that accepts a string and returns a `Transaction` object.    
The JSON parser is defined as a function as it's really simple. It uses the built-in `json` module to parse the string to a `dict` and then passes it to `Transaction.parse_obj` which is generated by `pydantic` as I just mentioned.  
In case of the XML parser, it's a bit more complicated, so it's defined as a callable class. 
This parser uses `parse_obj` as well but before doing that, it needs to parse the XML string to a `dict` and to do that I used the `xmltodict` library.
Doing so, I ran into a problem because when arrays are parsed, they're put into a list called "element" directly under the required object. For example, this is how the structure of the generated dictionary for the taxes list looks like:
```
transaction{dict} -> taxes{dict} -> element{list}
```
When it should be looking like this:
```
transaction{dict} -> taxes{list}
```
To fix this, I had the option of hardcoding a list of the list objects in our model but, that would mean the parser has to be highly coupled to the model and in case any new lists are added to the model, the parser has to be edited to support the new list. 
Instead, I implemented a DFS solution where it starts at the root and goes recursively over all the objects under it looking for any objects named "element" and if it finds one, it flattens it with its parent to achieve the required structure. This might be a bit more error prone, but it has the advantage of being decoupled from the model.

## Validate
This module has a single class `TransactionValidator` which represents the main API of this library. As mentioned before, `TransactionValidator` requires a parser which was defined earlier.  
After parsing the passed string, the `TransactionValidator` runs the `Transaction` through the following validation tests to make sure all fields are consistent:
1. Goes over all money values in the transaction and makes sure all of them are in the same currency. Here I ran into the same problem as the XML parser. I needed to check all money values in the transaction and instead of doing a hardcoded solution, I went with a recursive, more general solution.
2. For each item, it validates that all taxes of an item are consistent with the net sales money and the total money.
3. Sums up the total money and net sales money for all items and validates that they're consistent with the total collected money and the tax money of the transaction.
